# -*- coding: utf-8 -*-
"""SmallDataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JCsL_Dhdm7yFlHUN_YZ4nm1jgZukH70f
"""

print("Holdback score:", model.score(x_test,y_test))
print("Processing time:", time_ho)

import scipy as sp
from scipy import stats
from scipy.stats import uniform
import numpy as np
import matplotlib
from matplotlib import pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn import datasets, linear_model, svm, metrics
from sklearn.model_selection import train_test_split, cross_val_predict, cross_val_score, LeaveOneOut
from timeit import default_timer as timer
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

wine = datasets.load_wine()
wine.data.shape, wine.target.shape
sns.set_style('dark')

headers = wine.feature_names
wineDF = pd.DataFrame(wine.data,columns=headers)
wineDF

x_train, x_test, y_train, y_test = train_test_split(wine.data, wine.target, test_size=0.2, random_state=0)

# physData = pd.DataFrame(phys.data,columns=datasets.load_linnerud().feature_names)
# physData.head
print(x_train.shape,y_train.shape)
print(x_test.shape,y_test.shape)

"""## Train/Test Split"""

from sklearn.linear_model import LogisticRegression

logisticRegr = LogisticRegression(solver='liblinear',fit_intercept=True)
model = logisticRegr.fit(x_train,y_train)
score = model.score(x_test,y_test)
print(score)

start_ho = timer()

lm = linear_model.LogisticRegression()
model =lm.fit(x_train,y_train)
predictions = lm.predict(x_test)

end_ho = timer()

time_ho = (end_ho - start_ho)

plot = sns.scatterplot(y_test,predictions)
plot.set(xlabel='Given',ylabel='Prediction')

x_plot = np.linspace(0,2,100)
y_plot = x_plot
plt.plot(x_plot,y_plot,color='r')
#--------------------------------------------
print(y_test)

print("Holdback score:", model.score(x_test,y_test))
print("Processing time:", time_ho)

"""## K-fold"""

# start_ho = timer()
# # fit a model using linear model method from sklearn
# lm = linear_model.LinearRegression()
# model = lm.fit(x_train, y_train)

# # generate predictions
# predictions = lm.predict(x_test)

# end_ho = timer()

# time_ho = (end_ho - start_ho)

# start_ho_score = timer()
# # model score (r^2)
# model.score(x_test, y_test)
# end_ho_score = timer()

# ho_score_time = (end_ho_score - start_ho_score)

wineArray = np.array(wineDF)
y=wine.target

start_kfold = timer()

lm_k = linear_model.LogisticRegression()
k_predictions = cross_val_predict(lm_k, wineArray,y,cv=10)

end_kfold = timer()

kfold_time = (end_kfold - start_kfold)

k_predictions

kfold_score_start = timer() 
# find the max score from the k-fold models usinf cross_val_score
scores = cross_val_score(lm_k, wineArray, y, cv=10)
kfold_score_end = timer()

kfold_score_time = (kfold_score_end - kfold_score_start)

plotk = sns.distplot(scores, bins=4,kde=False,rug=True)
sns.kdeplot(scores,shade=True,color='navy')

print("Average of the scores:", scores.sum()/len(scores))
print("Accuracy score:", metrics.accuracy_score(y,k_predictions))
print("Processing time:", kfold_score_time)

"""## LOOCV"""

start_LOO = timer()
loo = LeaveOneOut()
LOO_predictions = cross_val_predict(lm_k, wineArray, y, cv=(loo))
LOO_predictions
end_LOO = timer()

LOO_time = (end_LOO - start_LOO)

print(metrics.accuracy_score(wine.target, LOO_predictions))
print(metrics.classification_report(wine.target,LOO_predictions))

LOO_score_start = timer()
looScores = cross_val_score(lm_k,wineArray,y,cv=loo,scoring='accuracy')
LOO_score_end = timer()

LOO_score_time = (LOO_score_end - LOO_score_start)
looScores

print("Average of scores:", looScores.sum()/len(looScores))
print("Accuracy score:", metrics.accuracy_score(y,LOO_predictions))
print("LOOCV score time:", LOO_score_time)

plotk = sns.distplot(looScores, bins=4)
sns.kdeplot(looScores,shade=True,color='navy')

"""## SUMMARIES"""

print("The Holdback method returned a score of", model.score(x_test,y_test), "with a processing time of",time_ho)
print("The Kfold method returned a score of", scores.sum()/len(scores), "with a processing time of",kfold_score_time)
print("Th LOOCV method returned a score of", metrics.accuracy_score(y,LOO_predictions),"with a processing time of",LOO_score_time)
